
#include <stdio.h>
#include <string.h>


#include "libxorscura.h"


/* XXX 
		ToDo:
			- Fix free() inside xorscura_clear_xod() segfaulting on non heap. :(
	 XXX */

int main(){

	struct xod *data;


	// Note, I would normally put these obscured arrays in their own .h file for readability. However, for an example, this works inline.

	/*
		 $ printf 'Can you guess my secret? Go ahead! Try!!\ninput> ' | ./xorscura -C
plaintext: {0x43,0x61,0x6e,0x20,0x79,0x6f,0x75,0x20,0x67,0x75,0x65,0x73,0x73,0x20,0x6d,0x79,0x20,0x73,0x65,0x63,0x72,0x65,0x74,0x3f,0x20,0x47,0x6f,0x20,0x61,0x68,0x65,0x61,0x64,0x21,0x20,0x54,0x72,0x79,0x21,0x21,0x0a,0x69,0x6e,0x70,0x75,0x74,0x3e,0x20}
seed: 2882791357
key: {0x1b,0x22,0xef,0x21,0x59,0xfd,0x15,0x20,0xe1,0xfd,0xc7,0x55,0xef,0x8a,0x97,0x7e,0x91,0xa6,0xd7,0x48,0x17,0xe4,0xae,0x4c,0x8a,0x2f,0x67,0x7e,0x8a,0x47,0x57,0x64,0xbc,0xa4,0x2b,0x55,0xfd,0x02,0xd5,0x47,0xd1,0x60,0x3f,0x0a,0x9d,0x7f,0x31,0x49}
cipher: {0x58,0x43,0x81,0x01,0x20,0x92,0x60,0x00,0x86,0x88,0xa2,0x26,0x9c,0xaa,0xfa,0x07,0xb1,0xd5,0xb2,0x2b,0x65,0x81,0xda,0x73,0xaa,0x68,0x08,0x5e,0xeb,0x2f,0x32,0x05,0xd8,0x85,0x0b,0x01,0x8f,0x7b,0xf4,0x66,0xdb,0x09,0x51,0x7a,0xe8,0x0b,0x0f,0x69}
	 */
	unsigned char prompt_key[] = {0x1b,0x22,0xef,0x21,0x59,0xfd,0x15,0x20,0xe1,0xfd,0xc7,0x55,0xef,0x8a,0x97,0x7e,0x91,0xa6,0xd7,0x48,0x17,0xe4,0xae,0x4c,0x8a,0x2f,0x67,0x7e,0x8a,0x47,0x57,0x64,0xbc,0xa4,0x2b,0x55,0xfd,0x02,0xd5,0x47,0xd1,0x60,0x3f,0x0a,0x9d,0x7f,0x31,0x49};
	unsigned char prompt_ciphertext[] = {0x58,0x43,0x81,0x01,0x20,0x92,0x60,0x00,0x86,0x88,0xa2,0x26,0x9c,0xaa,0xfa,0x07,0xb1,0xd5,0xb2,0x2b,0x65,0x81,0xda,0x73,0xaa,0x68,0x08,0x5e,0xeb,0x2f,0x32,0x05,0xd8,0x85,0x0b,0x01,0x8f,0x7b,0xf4,0x66,0xdb,0x09,0x51,0x7a,0xe8,0x0b,0x0f,0x69};

	/*
		 $ printf 'I <3 PONIES!!!' | ./xorscura -C
plaintext: {0x49,0x20,0x3c,0x33,0x20,0x50,0x4f,0x4e,0x49,0x45,0x53,0x21,0x21,0x21}
seed: 1549656503
key: {0xd9,0x75,0x45,0x62,0x14,0x9b,0x4d,0x72,0xec,0x24,0x2b,0x31,0x9d,0x40}
cipher: {0x90,0x55,0x79,0x51,0x34,0xcb,0x02,0x3c,0xa5,0x61,0x78,0x10,0xbc,0x61}
	 */
	unsigned int secret_seed = 1549656503;
	unsigned char secret_ciphertext[] = {0x90,0x55,0x79,0x51,0x34,0xcb,0x02,0x3c,0xa5,0x61,0x78,0x10,0xbc,0x61};

	/*
		 $ printf 'Nope. Not it.\n' | ./xorscura -C
plaintext: {0x4e,0x6f,0x70,0x65,0x2e,0x20,0x4e,0x6f,0x74,0x20,0x69,0x74,0x2e,0x0a}
seed: 3388515445
key: {0xcd,0x6e,0x2d,0x0a,0xc2,0x3d,0xef,0x33,0xff,0x56,0xb0,0x79,0x9f,0xea}
cipher: {0x83,0x01,0x5d,0x6f,0xec,0x1d,0xa1,0x5c,0x8b,0x76,0xd9,0x0d,0xb1,0xe0}
	 */
	unsigned int failure_seed = 3388515445;
	unsigned char failure_ciphertext[] = {0x83,0x01,0x5d,0x6f,0xec,0x1d,0xa1,0x5c,0x8b,0x76,0xd9,0x0d,0xb1,0xe0};

	/*
		 $ printf 'YES! You know my secret!!!\n' | ./xorscura -C
plaintext: {0x59,0x45,0x53,0x21,0x20,0x59,0x6f,0x75,0x20,0x6b,0x6e,0x6f,0x77,0x20,0x6d,0x79,0x20,0x73,0x65,0x63,0x72,0x65,0x74,0x21,0x21,0x21,0x0a}
seed: 2741107579
key: {0x31,0x78,0xad,0x08,0x03,0x10,0x97,0x4c,0x83,0x3f,0x9d,0x2d,0xa1,0x2d,0x64,0x61,0x4b,0xea,0xc7,0x58,0x6f,0xdc,0xa6,0x27,0xbf,0x0a,0xe2}
cipher: {0x68,0x3d,0xfe,0x29,0x23,0x49,0xf8,0x39,0xa3,0x54,0xf3,0x42,0xd6,0x0d,0x09,0x18,0x6b,0x99,0xa2,0x3b,0x1d,0xb9,0xd2,0x06,0x9e,0x2b,0xe8}
	 */
	unsigned int success_seed = 2741107579;
	unsigned char success_ciphertext[] = {0x68,0x3d,0xfe,0x29,0x23,0x49,0xf8,0x39,0xa3,0x54,0xf3,0x42,0xd6,0x0d,0x09,0x18,0x6b,0x99,0xa2,0x3b,0x1d,0xb9,0xd2,0x06,0x9e,0x2b,0xe8};


	// START CODE

	if((data = (struct xod *) calloc(1, sizeof(struct xod))) == NULL){
		error(-1, errno, NULL);
	}

	data->key_buf = prompt_key;
	data->ciphertext_buf = prompt_ciphertext;
	data->buf_count = sizeof(prompt_ciphertext);

	if(xorscura_decrypt(data) == -1){
		error(-1, errno, NULL);
	}

	// Print the prompt.
	printf("%s", data->plaintext_buf);

	data->key_buf = NULL;
	data->ciphertext_buf = NULL;
	xorscura_free_xod(data);

#define TMP_BUF_SIZE 1024
	char tmp_buf[TMP_BUF_SIZE];
	char *tmp_ptr = NULL;
	fgets(tmp_buf, TMP_BUF_SIZE, stdin);
	tmp_ptr = strchr(tmp_buf, '\n');

	if(tmp_ptr){
		*tmp_ptr = '\0';
	}

	data->plaintext_buf = (unsigned char *) tmp_buf;
	data->buf_count = strlen(tmp_buf);

	// Using the strcmp() convention. 0 is match. 1 is not match. 
	int result = 1;

	if(data->buf_count != sizeof(secret_ciphertext)){
		goto REPORT_RESULT;
	}

	data->ciphertext_buf = secret_ciphertext;
	data->seed = secret_seed;

	if((result = xorscura_compare(data)) == -1){
		error(-1, errno, NULL);
	}

REPORT_RESULT:

	data->ciphertext_buf = NULL;
	data->plaintext_buf = NULL;
	data->buf_count = 0;
	data->seed = 0;

	if(result){
		// failure
		data->ciphertext_buf = failure_ciphertext;
		data->buf_count = sizeof(failure_ciphertext);
		data->seed = failure_seed;

	}else{
		// success
		data->ciphertext_buf = success_ciphertext;
		data->buf_count = sizeof(success_ciphertext);
		data->seed = success_seed;
	}

	if(xorscura_decrypt(data) == -1){
		error(-1, errno, NULL);
	}

	printf("%s", data->plaintext_buf);

	data->ciphertext_buf = NULL;
	xorscura_free_xod(data);
	free(data);

	return(0);
}
